# Quarternion
　四元数のクラスです。四元数は主に3Dではモデル変換とカメラのビューの管理に用いられます。カメラで活躍させるため、球面線形補間のメソッドを設けてあります。
## constructor
　4つの数を列挙します。デフォルトは1です。つまり虚部はすべてゼロということです。
## set
　引数は4つの数でもいいし、クォータニオンでもいいです。値をセットするだけの簡単な関数です。
## copy
　自身のコピーを返す関数です。4つの成分からなるので、シンプルですね。事実上はただのvec4です。気楽に扱えばよいかと思います。
## mult
　定数倍です。スカラーを引数に取り、何倍かします。たとえば-1倍で使います。第二引数で真偽値を取りますが、これはいつものimmutableで、デフォルトはfalseで、trueの場合は自身を変えずに変えた結果を出力します。
## multQ
　クォータニオンの右乗算です。ようやくクォータニオンらしい演算が出てきました。クォータニオンの流儀に従って右から掛け算します。クォータニオンの乗算には左乗算と右乗算があり、それぞれに意味があって重要です。Threeなんかは左乗算も用意しています...が、自分は用意しません。式を書く都合上、左乗算はどうしても混乱を招きやすいからです。主に私の。そういうわけで右乗算オンリーです。  

　簡単に説明すると、左乗算がグローバル回転で、右乗算がローカル回転です。以降のメソッド紹介の際に説明できればと思います。
## conj
　共役です。真偽値を取り、trueの場合は自身を変えずに新しい四元数を返します。これもimmutableで使う場合がほとんどでしょうが、統一するのは大事なのでデフォルトではnon-immutableとなっています。
## applyV
　ベクトルに作用させる関数です。自身のクォータニオンが軸と角度から生成される単位クォータニオンの場合に機能します。それで左乗算、それの共役で右乗算を施すと、対象のベクトルがその軸の周りに角度だけ回転する仕組みです。もっとも軸周りの回転をさせるだけならベクトルサイドにそういう関数があるので不要です。これが役に立つのはおそらく、クォータニオンで以って回転を実行しなければならない文脈においてでしょう。いちいち軸と角度を取り出さなくていいので便利ですね。
## mag, magSq
　クォータニオンのノルムと、ノルムの二乗です。ノルムの二乗、すなわちmagSqは要するに成分の平方和で、それの平方根としてmagを定めています。
## normalize
　ノルムで割るだけです。ゼロの場合はゼロとします。
## pow
　べき乗です。クォータニオンのべき乗はなじみが薄いですが、たとえばmebiusboxさんなんかがやっているのを後になって知りました。自分としては、Threeのslerpのsinを使った和による算出方法が肌に合わなかったので、独自のやり方でやりたいと思って用意することにしました。演算の仮定で-1倍していますが、クォータニオンは基本的に直交行列のレシピとして使うのです。その際、qと-qは同じ役割を果たすので、-1倍は些細な違いとして無視されます。つまり乗法群を中心で割っている...割愛します。ともかく、それで安全に角度を割り出し、角度に対しては乗算し、ノルムに対してはべき乗することでべき乗を求めています。軸と合わせて最終的に仕上げています。なおゼロの場合はゼロとします。
## slerp
　第一引数はクォータニオン、第二引数は割合です。第三引数は真偽値で、trueの場合新しいクォータニオンが返ります。いわゆる球面線形補間です。対象に自身の逆元を掛け、割合でべき乗して自身を右乗算して仕上げます。左乗算で仕上げることもできます。おそらく等価ですが、調べたい人は調べてみてください。
## getAxes
　クォータニオンから正規直交基底を算出します。クォータニオンには2つの姿があって、片方がこの正規直交基底です。無論、単位クォータニオンの場合に意味を持ちます。3本の列ベクトルが返るイメージですが、ベクトルの成分を横並びで用意しなければいけない都合上、どうしても転置してるように見えてしまいます。式を見ると分かりますがqでも-qでも同じ結果になります。つまりクォータニオンは-1倍しても同じ正規直交基底に対応するのです。
## static: fromAA
　軸と角度から単位クォータニオンを算出するための関数です。角度を2で割ってコサインで実部、サインと軸ベクトルで虚部を作ります。つまり、軸は正規化されまず。
## static: fromV
　ベクトルを虚部に並べてクォータニオンを作る関数です。fromAAで軸をこのベクトルに取り、角度にPIを取ったもの、ともいえます。
## static: fromAxes
　正規直交基底からクォータニオンを作る関数です。Threeの仕様を真似していますが、トレースが正の場合は独自のやり方でやらせていただきました。イメージ的にはやはり、3本の正規直交系をなすベクトルを列ベクトルとして縦に3本並べる感じです。トレースが正かどうかで分けるとなぜうまくいくかは式を見れば理解できるかと思います（難しいですが）。  

### クォータニオンの左乗算と右乗算
　単位クォータニオンq（ノルムが1）に対して、それが対応する正規直交基底のベクトルの組は、四元数の基底を1,i,j,kとして、
```math
qi\bar{q},~~~qj\bar{q},~~~qk\bar{q}
```
で与えられます。ゆえにqと-qは同じ基底に対応します。で、左乗算というのは、軸eと角度thetaに対して、
```math
s=\cos\frac{\theta}{2} + e\sin\frac{\theta}{2}
```
（ただしeをクォータニオンe_xi+e_yj+e_zkとみなしている）と置いた場合に、これを左から掛けたとき、qと対応する正規直交基底のベクトルが、それぞれグローバル空間で軸$e$の周りに角度thetaだけ回転するということです。  
　一方、これを右から掛ける場合、ローカル空間で軸eの周りに角度thetaだけ回転します。どういう意味かというと、
```math
e' = e_x(qi\bar{q}) + e_y(qj\bar{q}) + e_z(qk\bar{q})
```
の周りに回転するということです。たとえばiを右乗算する場合、正規直交基底のx軸に対応するqi\bar{q}の周りに回転します。これはこうすると見やすいです。
```math
qs = (qs\bar{q})q.
```
つまりsをqで「解釈」してできるベクトルの周りのグローバル回転ということです。このように、グローバルとローカルの回転を容易に扱えるのが、クォータニオンの魅力です。  
　なお、通常の（vRoidHubのような）orbitControlのカメラの操作では、定められた縦方向の軸の周りのグローバル回転と、横方向の軸周りのローカル回転を両方実行しています。今見たようにこれらは乗算の方向が違うので可換です。ゆえに、マウスポインターの移動方向を縦横に分解して、それぞれ処理に用いても矛盾が生じないわけです。同じ乗算の方向だった場合、どっちを先にするかで結果が変わってしまうからです。  

　Threeはベクトルにしてもクォータニオンにしても無数にメソッドを用意しています。数えきれないほどです。しかしすべてをあらゆるスケッチで日常的に用いるとは考えにくいので、必要に応じて自分が欲しい処理だけを備えたライブラリがあると便利だと思います。それでもこのくらいの量にはなってしまいますが...（多分かなり少ない方）。  

　めんどうなので説明をQiitaから移植しました。メソッドの少なさについてですが、はい。明らかに少ないと思います。あんまあれこれ用意するのがしんどいだけです。サボるの好きなので。
