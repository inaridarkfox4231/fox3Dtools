# MT4
　4次正方行列のクラスです。成分の並び順は行ベースで、列ベクトルに掛けることを想定していることを最初に注意しておきます。つまりp5とは異なる流儀を採用しています。これはどちらが正しいというよりは、哲学の問題です。glslも含めて全体で統一されている必要があります。それさえ守れば混乱は起きません。自分がこれを採用したいのは、glslにおいて
```glsl
  v *= m;
```
と
```glsl
  v = (v * m);
```
が同じ挙動になるからです。その一点のみです。仕組みさえ分かっていればこっちの方が分かりやすいです。
## constructor
　引数を列挙して定義するんですが、パターンがいくつかあります。まず何も指定しない（空っぽ）の場合は単位行列となります。長さ9の場合、それを左上に置いたうえで4x4の行列になるようにします。他の成分は単位行列のものとなります。最後に引数が16個の場合はそれらが並びます。並び順は最初に述べたように横並びです。これを気を付けておかないと掛け算の説明ができないので重要です。  
　該当しない場合は念のため0で埋めるようになってはいます。使わないと思いますが...  
　なお「m」というプロパティでFloat32Arrayで格納しています。ゆえにuniformMatrix234fに直接放り込むことができます。取り出す際は「m」でアクセスしてください。特に取得関数は設けていません。
```js
  const m0 = new MT4();
  // 1 0 0 0
  // 0 1 0 0
  // 0 0 1 0
  // 0 0 0 1
  const m1 = new MT4(1,2,3,4,5,6,7,8,9);
  // 1 2 3 0
  // 4 5 6 0
  // 7 8 9 0
  // 0 0 0 1
  const m2 = new MT4(0,1,2,3,4,5,6,7,8,9,4,3,2,1,7,5);
  // 0 1 2 3
  // 4 5 6 7
  // 8 9 4 3
  // 2 1 7 5
```
## set
　引数は配列か、列挙か、行列です。行列というのはMT4クラスという意味です。内容をそのまま放り込みます。配列の場合、長さ9であればコンストラクタと同じ挙動をします。行列の場合は、「m」の内容をそのままコピーします。
## copy
　自身のコピーを返します。「m」しかプロパティが無いので、型付配列の内容をコピーするだけです。
## show
　ベクトルと同じで、内容を文字列形式で取得する関数です。改行込みで4行になって出力されます。引数のデフォルトはfalseですが、trueにすることで実行と同時にコンソール出力が実行されます。内容を手っ取り早く確認するのにとても便利です。
```js
  const m = new MT4(1,2,3,4,1,2,5,6,1,2,7,8,9,9,9,0);
  m.show(true);
  /*
    1, 2, 3, 4
    1, 2, 5, 6
    1, 2, 7, 8,
    9, 9, 9, 0,
  */
```
## init
　単位行列の内容にします。初期化です。主に掛け算で使うので、単位元は単位行列というわけです。ゼロ行列は出てきません。
## multV
　ベクトルを引数に取ります。ここではVectaですがp5.Vectorでも問題ないかと思います。戻り値はベクトルです。第二引数は真偽値で、これのデフォルトはfalseで、ベクトルを変化させます。違うものを取りたい場合はtrueを指定します。この処理はどういう処理かというと、ベクトル(x,y,z)を一時的に4次元のベクトル(x,y,z,1)にしたうえで、列ベクトルとみなして行列を左から掛ける処理を実行し、結果のx,y,z成分で以って再びベクトルにするものです。つまり平行移動の行列も作用させることができます。CPUサイドでモデル行列を乗算したい場合に使います。ポイントライトの位置を事前にビュー座標系に落としておくのにも使うかと思います。
```js
  const m = new MT4(1,1,1,1, 0,1,1,1, 0,0,1,1, 0,0,0,1);
  const v = new Vecta(1,2,3);
  const w = m.multV(v); // 7, 6, 4
  v.show(true); // 7, 6, 4
  const w1 = m.multV(v, true); // 18, 11, 5
  v.show(true); // 7, 6, 4
```
## multN
　multVとほぼ同じですが、あちらでは(x,y,z)を(x,y,z,1)とみなすのに対し、こちらでは(x,y,z)を(x,y,z,0)とみなして計算します。ライトのベクトルにビュー行列をかましたい場合などに使います。ライティングでは基本的にビュー空間で処理を実行するからです。
```js
  const m = new MT4(1,1,1,1, 0,1,1,1, 0,0,1,1, 0,0,0,1);
  const v = new Vecta(1,2,3);
  const w = m.multN(v); // 6, 5, 3
  v.show(true); // 6, 5, 3
```
## multM
　行列の右乗算です。例によって左乗算の関数は用意されていないので、行列を乗算する唯一の関数です。メソッドの書き方の都合上、左乗算は混乱の原因になるので用意していません。行列の成分を横並びで用意したうえで、数学と同じ流儀で計算します。  
　GLSLの行と列の反転を考慮しなければいけない都合上、この辺はライブラリによってはかなりひねくれた処理を実行していますが、自分としては数学の流儀に愚直に従った方が混乱が少ないと思っています。  
　なお、第二引数でtrueを指定することで自分と異なる行列を返すことができます。この辺も他のクラスと統一しています。
```js
  const m0 = new MT4(1,1,1,1, 0,1,1,1, 0,0,1,1, 0,0,0,1);
  const m1 = MT4(1,0,0,0, 1,1,0,0, 1,1,1,0, 1,1,1,1);
  m0.multM(m1);
  m0.show(true);
  /*
    4, 3, 2, 1,
    3, 3, 2, 1,
    2, 2, 2, 1,
    1, 1, 1, 1
  */
```
## transpose
　転置です。trueを指定すると違う行列が返り、自身は変化させません（immutable）。何度も言いますがimmutable=trueで統一しているのは自分が混乱したくないからです。
```js
  const m = new MT4(1,2,3,4, 5,6,7,8, 4,2,6,9, 1,1,3,5);
  m.transpose(); // 1,5,4,1, 2,6,2,1, 3,7,6,3, 4,8,9,5
```
## get3x3
　左上の3x3部分をFloat32Arrayの形式で長さ9の配列として返します。並び順は横並びです。同じ順序で、途中を省く形で用意します。
```js
  const m = new MT4(1,2,3,0, 4,5,6,0, 7,8,9,0, 1,1,1,1);
  const t = m.get3x3(); // Float32Array() 1,2,3,4,5,6,7,8,9
```
## getInverseTranspose3x3
　左上の3x3部分の転置行列の逆行列を取ります。これはなぜかというと法線のモデルビュー変換に伴う変化がこれで算出できるからです。詳しい説明は内積を使うと割と簡単にできる...のですが割愛します。モデル変換に使う場合と、モデルビュー変換に使う場合があり、いずれも正確に法線情報をいじるのに使います。インスタンシングでは内部で実行することもあるかと思います。モデル変換もそうですが、あくまで外部で実行する場合のための処理です。uniformですから。
## setScale
　引数は列挙で3つですが、一つの場合は全部一緒になります。デフォルトはすべて1なので、たとえば引数が2つの場合、3つ目は1となります。スケール変換行列をセットするための関数です。上記のmultVをベクトルに実行すると、各々の成分にそれぞれの対角成分が乗算されます。
```js
  const s = new MT4();
  s.setScale(2,3,5).show(true);
  // 2, 0, 0, 0,
  // 0, 3, 0, 0,
  // 0, 0, 5, 0.
  // 0, 0, 0, 1,
```
## setRotation
　引数は軸と角度です。軸は成分列挙でも配列でもベクトルでも可能です。軸ベクトルは自動的に正規化して使います。上記のmultVをベクトルに実行すると、軸の周りに角度だけ回転します（列ベクトルへの作用）。そういう行列であることと、行ベースで数を並べるという規約の都合上、行列の成分の並びはきちんと決まります。それが重要なことです。  

　列ベクトルに作用させる形式にこだわるのは数学リソースを適切に活用するためです。縦横でいちいち悩みたくないのです。
```js
  const r = new MT4();
  r.setRotation(0,0,1,theta).show(true);
  // cos(theta), -sin(theta), 0, 0,
  // sin(theta), cos(theta), 0, 0,
  // 0, 0, 1, 0,
  // 0, 0, 0, 1
```
## setTranslation
　引数は3つの数ですが、ベクトルや長さ3の配列でもOKとします。平行移動です。multVの作用が平行移動になります。そういうわけなので、3つの数は一番右の、4番目の列に並びます。
```js
  const t = new MT4();
  t.setTranslation(2, 4, 9).show(true);
  // 1, 0, 0, 2,
  // 0, 1, 0, 4,
  // 0, 0, 1, 9,
  // 0, 0, 0, 1,
```
以上の3つの変換がいわゆるモデルのTRS変換で、この順に並べることで、スケール変換し、回転し、平行移動します。すなわち、縦横高さ方向に引き伸ばされたラグビーボールが、一定の回転をしながら、あらぬ方向にすっとんでいくわけです。Blenderではまさにこの順でトランスフォームが実行される仕組みになっています（それがすべてではないですが...）。とてもわかりやすいですね。

## setPerseProjection
　投射投影の射影変換の行列を与える関数です。簡単なライブラリを想定しているので射影変換に関してはあまり深く考えていません。そのうちきちんと整備するかもしれないです。最終的にこれを実行することで正規化デバイス座標、及び正規化ビューポート座標を算出します。正規化ビューポート座標のz成分は深度値と呼ばれています。webGLでは0～1の値で、0が一番近く、1が一番遠いです。外部でこの値を算出するために用いることがあるかもしれません（いわゆるスクリーン座標）。
## setMatrixFromQuarternion
　クォータニオンから行列を作る関数も用意しました。回転だけで良かったんですが、もったいなかったのでノルムを使って単純定数倍のスケール変換をくっつける仕様にしました。モデル変換で遊ぼうと思ったようです。いたずら好きなんだからもう。  
　どうでもいいんですが、補間で行ったり来たりさせるだけで凄い楽しいんですよ。ごめんなさい。  
　当然ですが、単位クォータニオンの場合はそれが対応する回転の行列をセットする関数となります。いわばsetRotationの変種ですね。
## static: getScale
　スケール変換の行列を取得するための関数です。引数の仕組みはsetRotationと完全に同じです。以下のstaticはすべてそういう関数です。
## static: getRotation
　回転変換の行列を取得するための関数です。
## static: getTranslation
　平行移動の行列を取得するための関数です。
## static: getPerseProjection
　投射投影の射影変換行列を取得するための関数です。
## static: getMatrixFromQuarternion
　クォータニオンから行列を作って取得するための関数です。
